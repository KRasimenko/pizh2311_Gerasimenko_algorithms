# Лабораторная работа №2. Введение в алгоритмы. Сложность. Поиск.

Выполнил студент 3 курса Северо-Кавказского федерального университета группы ПИЖ-б-о-23-1 **Герасименко Константин Васильевич**

**Цель работы**: Освоить понятие вычислительной сложности алгоритма. Получить практические навыки реализации и анализа линейного и бинарного поиска. Научиться экспериментально подтверждать теоретические оценки сложности O(n) и O(log n).

### Линейный поиск
- Последовательно проверяет каждый элемент массива.
- В худшем случае потребуется пройти все `n` элементов.
- **Сложность:**
  - Лучший случай: `O(1)` (если элемент первый).
  - Худший случай: `O(n)` (если элемент последний).

### Бинарный поиск
- Работает только на отсортированном массиве.
- Делит массив пополам и проверяет, в какой половине искать дальше.
- Повторяет шаги, пока не найдёт элемент или не закончатся варианты.
- **Сложность:**  
  - Лучший случай: `O(n//2)` (если элемент в середине).
  - Худший случай: `O(log n)`.

Для работы с двумя видами поиска было написано 2 функции
[![1.png](https://i.postimg.cc/MG9SpDmm/1.png)](https://postimg.cc/1gVTWDT8)

Для определения среднего времени выполнения была написана функция, запускающая алгоритмы поиска 5 раз и считая среднее время
[![2.png](https://i.postimg.cc/7h8TY04X/2.png)](https://postimg.cc/MM5G9cvj)

### Этапы работы программы:
[![3.png](https://i.postimg.cc/3RVJKTXT/3.png)](https://postimg.cc/ZBPhcXs7)
1. **Вывод конфигурации ПК** . В начале печатается информация о системе: процессор, оперативная память, версия ОС и Python. Это необходимо для корректного воспроизведения эксперимента и анализа производительности.
2. **Определение размеров массивов**. Задаётся список размеров массивов:  [1000, 2000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000]. Для каждого размера будет создан отсортированный список.
3. **Подготовка структур для хранения времени**. Создаются два словаря:
- `linear_times` — время линейного поиска;  
- `binary_times` — время бинарного поиска.  
В каждом словаре ключами являются случаи поиска: *Первый*, *Последний*, *Средний*, *Отсутствующий*.
4. **Основной цикл по размерам массива** . Для каждого размера формируется массив `[0, 1, 2, ..., n-1]`.
5. **Формирование целей поиска**  Для тестирования выбираются 4 варианта поиска:
- первый элемент,
- последний элемент,
- средний элемент,
- элемент, отсутствующий в массиве.
6. **Замеры времени поиска**
Для каждой цели выполняются:
- линейный поиск,
- бинарный поиск.
Результаты замеров добавляются в соответствующие словари.
7. **Вывод промежуточных результатов**  В консоль печатается информация о цели поиска и времени выполнения обоих алгоритмов.
[![4-1.png](https://i.postimg.cc/d0HwQY20/4-1.png)](https://postimg.cc/nsD6TNw8)
[![4-2.png](https://i.postimg.cc/52pMpVkm/4-2.png)](https://postimg.cc/XrZh7TWZ)
[![4-3.png](https://i.postimg.cc/DyFDNNGp/4-3.png)](https://postimg.cc/jCgZwZZy)


Теоретически линейный поиск имеет сложность `O(n)`, поэтому его время работы должно расти прямо пропорционально размеру массива. Бинарный поиск имеет сложность `O(log n)`, значит, его время должно увеличиваться очень медленно, даже на очень больших массивах.

Практические замеры это подтвердили: хотя при поиске первого элемента линейный поиск намного быстрее бинарного, по мере увеличения массива линейный поиск становится медленнее, а бинарный поиск остаётся почти постоянным по времени.

Таким образом, теория и практика совпадают: бинарный поиск значительно эффективнее на больших данных.

### Построение графиков
Чтобы визуализировать данные построим два графика: обычный график и логарифмический

[![5.png](https://i.postimg.cc/QxdyJT1H/5.png)](https://postimg.cc/3Wz1KWLT)

В данном блоке кода визуализируются результаты замеров времени работы линейного и бинарного поиска. Построение делится на два этапа: обычная шкала и логарифмическая шкала.

### Графики в обычной шкале
- Создаётся сетка из 4 графиков (2x2) для разных сценариев поиска: *Первый*, *Последний*, *Средний*, *Отсутствующий*.  
- Для каждого случая строятся две линии:
  - **Линейный поиск** (`marker="o`)  
  - **Бинарный поиск** (`marker="s`)  
- Добавляются подписи осей, заголовки графиков, сетка и легенда.  
- `plt.tight_layout()` обеспечивает корректные отступы, чтобы графики и подписи не накладывались друг на друга.  
- `plt.show()` отображает графики пользователю.

[![Figure-1.png](https://i.postimg.cc/YqKMbkM5/Figure-1.png)](https://postimg.cc/mhwvgvcj)

### Графики в логарифмической шкале
- Повторяется та же структура (2x2 графика для четырёх сценариев), но для оси Y используется **логарифмическая шкала** (`ax.set_yscale("log")`).
- Лог-шкала позволяет наглядно сравнить время работы алгоритмов при больших размерах массивов, особенно когда линейный поиск растёт сильно, а бинарный остаётся почти постоянным.
- Параметр `ax.grid(True, which="both")` добавляет сетку как для основных делений оси, так и для промежуточных (минорных), что улучшает читаемость графиков.

[![Figure-2.png](https://i.postimg.cc/hv9FHzcH/Figure-2.png)](https://postimg.cc/D4yYGzWg)

## Выводы на основе графиков

- Для **линейного поиска** время работы растёт почти линейно с увеличением размера массива. Особенно это заметно при поиске **последнего элемента** или **отсутствующего**, когда алгоритм проходит почти весь массив.  
- Для **бинарного поиска** время практически не изменяется даже на больших массивах. На логарифмической шкале видно, что рост времени очень медленный, что подтверждает теоретическую сложность `O(log n)`.  
- На больших массивах (от 1 миллиона элементов и выше) бинарный поиск выигрывает многократно: линии линейного поиска резко поднимаются вверх, а линии бинарного остаются почти горизонтальными.  

**Итог:**  
Графики наглядно демонстрируют, что бинарный поиск гораздо эффективнее для больших отсортированных массивов, а линейный поиск подходит только для небольших наборов данных или при поиске первого элемента.







