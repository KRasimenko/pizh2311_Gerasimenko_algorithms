# Лабораторная работа: Рекурсия и мемоизация

## Описание файлов
![linked_list.py](pics/1.png)
### recursion.py
Этот файл содержит базовые рекурсивные алгоритмы:
```python
def factorial(n: int) -> int:
    """
    Рекурсивное вычисление факториала числа n.
    """
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)
    # Временная сложность: O(n)
    # Глубина рекурсии: O(n)


def fibonacci(n: int) -> int:
    """
    Рекурсивное вычисление n-го числа Фибоначчи.
    Последовательность: 0, 1, 1, 2, 3, 5, 8, ...
    в глобальной переменной call_count_naive считает
    количество вызовов функции
    """
    global call_count_naive
    call_count_naive += 1
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
    # Временная сложность: O(2^n)
    # Глубина рекурсии: O(n)


def fast_power(a: int, n: int) -> int:
    """
    Быстрое возведение числа a в степень n через деление степени пополам.
    Используется принцип:
        a^n = (a^(n//2))^2  если n чётное
        a^n = a * (a^(n-1)) если n нечётное
    """
    if n == 0:
        return 1
    if n % 2 == 0:
        half = fast_power(a, n // 2)
        return half * half
    else:
        return a * fast_power(a, n - 1)
    # Временная сложность: O(log n)
    # Глубина рекурсии: O(log n)
```
- **`factorial(n)`** - рекурсивное вычисление факториала числа n
  - Временная сложность: O(n)
  - Глубина рекурсии: O(n)
  - Базовый случай: n == 0 или n == 1
  - Рекурсивный шаг: n * factorial(n-1)

- **`fibonacci(n)`** - наивная рекурсивная реализация чисел Фибоначчи
  - Временная сложность: O(2^n) - экспоненциальная
  - Глубина рекурсии: O(n)
  - Базовый случай: n <= 1
  - Рекурсивный шаг: fibonacci(n-1) + fibonacci(n-2)
  - Содержит глобальный счетчик `call_count_naive` для подсчета вызовов

- **`fast_power(a, n)`** - быстрое возведение в степень
  - Временная сложность: O(log n)
  - Глубина рекурсии: O(log n)
  - Использует принцип: a^n = (a^(n//2))^2 для четных n

### memoization.py
Этот файл демонстрирует оптимизацию рекурсивных алгоритмов с помощью мемоизации:

```python
import time

import matplotlib.pyplot as plt
from functools import lru_cache

import recursion
from recursion import fibonacci


def measure_time(func, *args, **kwargs):
    """
    функция-обёртка для измерения времени выполнения функции
    """
    start = time.time()
    result = func(*args, **kwargs)
    end = time.time()
    elapsed = end - start
    return result, elapsed


call_count_memo = 0


@lru_cache(maxsize=None)
def fibonacci_cached(n: int) -> int:
    """
    Рекурсивная функция для вычисления n-го числа Фибоначчи.
    Используется мемоизация через @lru_cache, чтобы избежать повторных
    вычислений
    Последовательность: 0, 1, 1, 2, 3, 5, 8, ...
    """
    global call_count_memo
    call_count_memo += 1
    if n <= 1:
        return n
    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)
    # Временная сложность: O(n)
    # Глубина рекурсии: O(n)
```
- **`fibonacci_cached(n)`** - мемоизированная версия Фибоначчи с декоратором `@lru_cache`
  - Временная сложность: O(n) - линейная
  - Глубина рекурсии: O(n)
  - Использует кэширование для избежания повторных вычислений
  - Содержит счетчик `call_count_memo` для подсчета вызовов

- **`measure_time(func, *args, **kwargs)`** - функция для измерения времени выполнения

- **График сравнения производительности** - визуализация разницы между наивной и мемоизированной версиями для различных значений n
```python
if __name__ == "__main__":
    pc_info = """
    Конфигурация ПК:
    - Процессор: 11th Gen Intel(R) Core(TM) i5-1155G7 @ 2.50 GHz
    - Оперативная память: 16,0 ГБ (доступно: 15,8 ГБ)
    - Тип системы: 64-разрядная операционная система, процессор x64
    - ОС: Windows 11 Pro
    - Версия: 24H2
    - Сборка ОС: 26100.4946
    - Python: 3.13.3
    """
    print(pc_info)
    ns = [10, 15, 20, 25, 30, 35]
    times_naive = []
    times_memo = []

    for n in ns:
        recursion.call_count_naive = 0
        result_naive, t_naive = measure_time(fibonacci, n)
        times_naive.append(t_naive)

        fibonacci_cached.cache_clear()
        call_count_memo = 0  # сбрасываем перед измерением
        result_memo, t_memo = measure_time(fibonacci_cached, n)
        times_memo.append(t_memo)

        print(f"n={n}: Наивная={t_naive:.8f}s, Мемоизация={t_memo:.8f}s")

    # Построение графика
    plt.plot(ns, times_naive, marker='o', label='Наивная рекурсия')
    plt.plot(ns, times_memo, marker='o', label='Мемоизация')
    plt.xlabel("n (число Фибоначчи)")
    plt.ylabel("Время выполнения, секунд")
    plt.title("Сравнение времени выполнения Фибоначчи")
    plt.yscale("log")
    plt.legend()
    plt.grid(True)
    plt.show()
```
### recursion_tasks.py
Файл с дополнительными рекурсивными задачами:
```python
import os


def binary_search_recursive(arr, target, left=0, right=None):
    """
    Рекурсивный алгоритм бинарного поиска.
    arr      — отсортированный список (по возрастанию)
    target   — искомое значение
    left     — левая граница диапазона поиска
    right    — правая граница диапазона поиска (по умолчанию конец массива)

    Возвращает индекс элемента, если найден, иначе -1.
    """
    if right is None:
        right = len(arr) - 1

    if left > right:
        return -1

    mid = (left + right) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)
    # Временная сложность: O(log n)
    # Глубина рекурсии: O(log n)


max_depth = 0


def walk_directory(path: str, indent: int = 0, current_depth: int = 0):
    """
    Рекурсивный обход файловой системы с измерением глубины рекурсии.

    path          — начальный путь
    indent        — отступ для вывода
    current_depth — текущая глубина рекурсии
    """
    global max_depth
    if current_depth > max_depth:
        max_depth = current_depth

    if not os.path.exists(path):
        print("Путь не существует:", path)
        return

    print(" " * indent + f"[{os.path.basename(path) or path}]")

    if os.path.isdir(path):
        for name in os.listdir(path):
            new_path = os.path.join(path, name)
            walk_directory(new_path, indent + 4, current_depth + 1)
    else:
        print(" " * (indent + 4) + os.path.basename(path))


def hanoi(n, source="A", target="C", auxiliary="B", towers=None):
    """
    Рекурсивное решение задачи Ханойские башни с ASCII-визуализацией.

    n         — количество дисков
    source    — стержень, с которого снимаем диск
    target    — стержень, на который ставим диск
    auxiliary — вспомогательный стержень
    towers    — текущее состояние башен (списки дисков)
    """
    if towers is None:
        towers = {
            "A": list(range(n, 0, -1)),
            "B": [],
            "C": []
        }
        print("Начальное состояние:")
        print_towers(towers, n)
        return hanoi(n, source, target, auxiliary, towers)

    if n == 0:
        return

    # 1. Переместить n-1 дисков с source на auxiliary через target
    hanoi(n - 1, source, auxiliary, target, towers)

    # 2. Переместить самый большой диск
    disk = towers[source].pop()
    towers[target].append(disk)
    print(f"\nПереместить диск {disk} с {source} на {target}")
    print_towers(towers, max(sum(len(t) for t in towers.values()), n))

    # 3. Переместить n-1 дисков с auxiliary на target через source
    hanoi(n - 1, auxiliary, target, source, towers)


def print_towers(towers, n):
    """Печать текущего состояния стержней в ASCII."""
    if n == 0:
        print("Пусто")
    for level in range(n, 0, -1):
        line = ""
        for peg in "ABC":
            if len(towers[peg]) >= level:
                disk_size = towers[peg][level - 1]
                line += " " * (n - disk_size) + "#" * (disk_size * 2 - 1) + " " * (n - disk_size) + "   "
            else:
                line += " " * (n - 1) + "|" + " " * (n - 1) + "   "
        print(line)
    print("-" * (n * 6 + 9))


if __name__ == "__main__":
    # Задача 1: Бинарный поиск
    print("Задача 1: Бинарный поиск")
    arr = list(range(1, 101))
    target = int(input("Введите число для поиска в массиве 1..100: "))
    index = binary_search_recursive(arr, target)
    if index != -1:
        print(f"Элемент {target} найден на индексе {index}.")
    else:
        print(f"Элемент {target} не найден.")
    # Задача 2: Обход файловой системы
    print("\nЗадача 2: Обход файловой системы")
    path = input("Введите путь для обхода (например, C:/ или ./): ")
    walk_directory(path)
    print(f"Максимальная глубина рекурсии: {max_depth}")
    # Задача 3: Ханойские башни
    print("\nЗадача 3: Ханойские башни")
    n = int(input("Введите количество дисков для Ханойских башен (например, 3 или 4): "))
    hanoi(n)
```

## Экспоненциальный рост времени выполнения наивного алгоритма Фибоначчи

Наивная рекурсивная реализация Фибоначчи имеет экспоненциальную временную сложность O(2^n). Это происходит из-за:

1. **Дублирования вычислений**: Для вычисления fib(n) функция вызывает fib(n-1) и fib(n-2), каждая из которых в свою очередь вызывает fib(n-2), fib(n-3) и т.д.

2. **Дерево рекурсивных вызовов**: Количество вызовов растет экспоненциально:
   - fib(5) = 15 вызовов
   - fib(10) = 177 вызовов  
   - fib(20) = 21,891 вызовов
   - fib(35) ≈ 18,446,744,073,709,551,615 вызовов

3. **Повторные вычисления**: Одно и то же значение вычисляется множество раз

## Анализ влияния мемоизации на сложность алгоритма

Мемоизация кардинально меняет временную сложность:

### До мемоизации:
- **Временная сложность**: O(2^n)
- **Количество вызовов**: экспоненциальное
- **Время выполнения**: растет экспоненциально

### После мемоизации:
- **Временная сложность**: O(n)
- **Количество вызовов**: 2n-1 (для fib(n))
- **Время выполнения**: растет линейно
- **Ускорение**: в тысячи раз для больших n

### Принцип работы мемоизации:
1. При первом вычислении fib(k) результат сохраняется в кэше
2. При повторном обращении к fib(k) результат берется из кэша
3. Каждое значение вычисляется только один раз

## Ответы на заключительные вопросы

### 1. Базовый случай и рекурсивный шаг

**Базовый случай** - это условие, при котором рекурсия останавливается и возвращает конкретное значение без дальнейших рекурсивных вызовов.

**Рекурсивный шаг** - это часть функции, которая вызывает саму себя с измененными параметрами, приближаясь к базовому случаю.

**Почему отсутствие базового случая приводит к ошибке:**
- Рекурсия становится бесконечной
- Происходит переполнение стека вызовов (Stack Overflow)
- Программа аварийно завершается

### 2. Механизм мемоизации

**Как работает мемоизация:**
- Использует декоратор `@lru_cache` из модуля `functools`
- Создает кэш для хранения результатов вычислений
- При первом вызове функции с определенными параметрами результат сохраняется
- При повторном вызове с теми же параметрами результат берется из кэша

**Изменение временной сложности:**
- **Наивная рекурсия**: O(2^n) - экспоненциальная
- **С мемоизацией**: O(n) - линейная
- **Ускорение**: от экспоненциального до линейного времени

### 3. Проблема глубокой рекурсии и стек вызовов

**Основная проблема:**
- Каждый рекурсивный вызов добавляет новый фрейм в стек вызовов
- Стек имеет ограниченный размер (обычно 1-8 МБ)
- При глубокой рекурсии стек переполняется

**Связь со стеком вызовов:**
- Стек вызовов хранит информацию о каждом вызове функции
- Включает параметры, локальные переменные, адрес возврата
- При переполнении стека возникает исключение `RecursionError`

**Решения:**
- Мемоизация (уменьшает количество вызовов)
- Итеративные алгоритмы
- Увеличение лимита рекурсии (не рекомендуется)

### 4. Алгоритм решения Ханойских башен для 3 дисков

**Алгоритм:**
1. Переместить 2 верхних диска с исходного стержня на вспомогательный
2. Переместить самый большой диск с исходного на целевой стержень
3. Переместить 2 диска с вспомогательного на целевой стержень

**Для 3 дисков (A, B, C - от малого к большому):**
1. A: стержень1 → стержень3
2. B: стержень1 → стержень2  
3. A: стержень3 → стержень2
4. C: стержень1 → стержень3
5. A: стержень2 → стержень1
6. B: стержень2 → стержень3
7. A: стержень1 → стержень3

**Количество ходов**: 2^n - 1 = 7 ходов для 3 дисков

### 5. Рекурсивные vs итеративные алгоритмы

**Преимущества рекурсии:**
- Более читаемый и понятный код
- Естественное отражение структуры задачи
- Легче реализовать для задач с древовидной структурой
- Меньше кода для сложных алгоритмов

**Недостатки рекурсии:**
- Переполнение стека при глубокой рекурсии
- Больше накладных расходов на вызовы функций
- Сложнее отлаживать
- Может быть медленнее из-за накладных расходов

**Преимущества итерации:**
- Нет риска переполнения стека
- Обычно быстрее по производительности
- Легче контролировать память
- Проще оптимизировать компилятором

**Недостатки итерации:**
- Более сложный код для рекурсивных по природе задач
- Может потребовать дополнительных структур данных (стек)
- Менее интуитивно для некоторых алгоритмов

## Заключение

Мемоизация является мощным инструментом оптимизации рекурсивных алгоритмов, позволяющим:
- Снизить временную сложность с экспоненциальной до линейной
- Уменьшить количество рекурсивных вызовов
- Сохранить читаемость рекурсивного кода
- Значительно ускорить выполнение программы

Выбор между рекурсией и итерацией зависит от конкретной задачи, требований к производительности и ограничений системы.
