# Отчет по лабораторной работе 5
# Хеш-функции и хеш-таблицы

**Дата:** [2025-11-14]
**Семестр:** 5
**Группа:** ПИЖ-б-о-23-1
**Дисциплина:** Алгоритмы и структуры данных
**Студент:** Герасименко Константин Васильевич

## Цель работы
Изучить принципы работы хеш-функций и хеш-таблиц. Освоить методы разрешения коллизий. Получить практические навыки реализации хеш-таблицы с различными стратегиями разрешения коллизий. Провести сравнительный анализ эффективности разных методов.

## Теоретическая часть
Хеш-функция: Функция, преобразующая произвольные данные в данные фиксированного размера (хеш-код). Требования: детерминированность, равномерное распределение, скорость вычисления.
Хеш-таблица: Структура данных, реализующая ассоциативный массив. Обеспечивает в среднем O(1) для операций вставки, поиска и удаления.
Коллизия: Ситуация, когда разные ключи имеют одинаковый хеш-код.
Метод цепочек (Chaining): Каждая ячейка таблицы содержит список элементов с одинаковым хешем. Сложность: O(1 + α), где α - коэффициент заполнения.
Открытая адресация (Open Addressing): Все элементы хранятся в самом массиве. При коллизии ищется следующая свободная ячейка согласно probe sequence.
Двойное хеширование (Double Hashing): Метод открытой адресации, использующий вторую хеш-функцию для определения шага probing

## Практическая часть
### hash_function.py
```python
def simple_hash(s):
    h = 0
    for ch in s:
        h += ord(ch)  # ord() возвращает числовой код символа
    return h


def poly_hash(s, p=31, m=10**9+9):
    h = 0
    p_pow = 1
    for ch in s:
        # Умножаем код символа на степень основания p и берём по модулю m
        h = (h + (ord(ch) - ord('a') + 1) * p_pow) % m
        p_pow = (p_pow * p) % m
    return h

def djb2(s):
    h = 5381  # стартовое "магическое" число
    for ch in s:
        h = ((h << 5) + h) + ord(ch)  # то же самое, что h * 33 + ord(ch)
    return h & 0xFFFFFFFF  # ограничиваем 32 битами (типично для DJB2)
```
В этом коде определены три разные функции хеширования строк, и каждая из них демонстрирует свой подход к вычислению числового значения на основе текста.

Сначала идёт самая простая версия — `simple_hash`. Она просто проходит по каждому символу строки, получает его числовой код через `ord()` и суммирует эти значения. Из-за такой примитивности порядок символов никак не влияет на результат: строки `abc` и `cab` будут давать одинаковый хеш. Это быстрый, но крайне ненадёжный способ, который подходит лишь для демонстрации принципа хеширования.

Следующая функция — `poly_hash`. Здесь используется идея полиномиального хеша: для каждого символа вычисляется произведение его положения в алфавите на некоторую степень основания `p`, после чего всё берётся по модулю большого числа `m`. На каждом шаге степень основания умножается на `p`, что позволяет учитывать порядок символов и снижать вероятность коллизий. Такой подход широко применяется в алгоритмах обработки строк, например, в поиске подстрок.

Последняя функция — `djb2`. Её автор — Дэн Бернстайн. Она начинается с заранее выбранного стартового числа и на каждом шаге умножает текущее значение хеша на 33, затем добавляет код символа. Операция сдвига `h << 5` — это быстрое умножение на 32, поэтому формула выглядит как `h * 33 + ord(ch)`. В конце результат ограничивается 32 битами, что соответствует типичной реализации. Такой алгоритм считается простым, быстрым и дающим хорошее распределение значений даже для похожих строк.

### hash_table_chaining.py

```python
from hash_function import poly_hash, djb2

class HashTableChaining:
    def __init__(self, size=8, hash_func=poly_hash):
        self.size = size
        self.buckets = [[] for _ in range(size)]
        self.count = 0
        self.hash_func = hash_func

    def _hash(self, key):
        return self.hash_func(key) % self.size

    def insert(self, key, value):
        h = self._hash(key)
        for i, (k, v) in enumerate(self.buckets[h]):
            if k == key:
                self.buckets[h][i] = (key, value)
                return
        self.buckets[h].append((key, value))
        self.count += 1

        # Проверяем, нужен ли ресайз
        if self.count / self.size > 0.7:
            self._resize()

    def _resize(self):
        old_buckets = self.buckets
        self.size *= 2
        self.buckets = [[] for _ in range(self.size)]
        self.count = 0
        for bucket in old_buckets:
            for key, value in bucket:
                h = self._hash(key)
                self.buckets[h].append((key, value))
                self.count += 1

    def find(self, key):
        """Поиск значения по ключу."""
        h = self._hash(key)
        for k, v in self.buckets[h]:
            if k == key:
                return v
        return None
# Средняя сложность O(1)
# Наихудшая слольность O(n)

class HashTableLinear:
    def __init__(self, size=8, hash_func=djb2):
        self.size = size
        self.table = [None] * size
        self.hash_func = hash_func

    def _hash(self, key):
        return self.hash_func(key) % self.size

    def insert(self, key, value):
        h = self._hash(key)
        for i in range(self.size):
            idx = (h + i) % self.size
            if self.table[idx] is None or self.table[idx][0] == key:
                self.table[idx] = (key, value)
                return
        raise Exception("Таблица переполнена")
    
    def find(self, key):
        """Поиск элемента по ключу."""
        h = self._hash(key)
        for i in range(self.size):
            idx = (h + i) % self.size
            if self.table[idx] is None:
                return None
            if self.table[idx][0] == key:
                return self.table[idx][1]
        return None
# Средняя сложность O(1)
# Наихудшая слольность O(n)
    
class HashTableDouble:
    def __init__(self, size=8, hash_func1=poly_hash, hash_func2=djb2):
        self.size = size
        self.table = [None] * size
        self.hash_func1 = hash_func1
        self.hash_func2 = hash_func2

    def _hash1(self, key):
        return self.hash_func1(key) % self.size

    def _hash2(self, key):
        return (self.hash_func2(key) % (self.size - 1)) + 1  # шаг не равен 0

    def insert(self, key, value):
        h1 = self._hash1(key)
        h2 = self._hash2(key)
        for i in range(self.size):
            idx = (h1 + i * h2) % self.size
            if self.table[idx] is None or self.table[idx][0] == key:
                self.table[idx] = (key, value)
                return
        raise Exception("Таблица переполнена")
    
    def find(self, key):
        """Поиск элемента по ключу."""
        h1 = self._hash1(key)
        h2 = self._hash2(key)
        for i in range(self.size):
            idx = (h1 + i * h2) % self.size
            if self.table[idx] is None:
                return None
            if self.table[idx][0] == key:
                return self.table[idx][1]
        return None
# Средняя сложность O(1)
# Наихудшая слольность O(n)
```
В этом коде реализованы три варианта хеш-таблиц, которые различаются способом обработки коллизий. Каждая структура получает ключ, вычисляет для него хеш и размещает значение в соответствующей позиции. Далее отличие заключается в том, что именно происходит, когда два разных ключа попадают в одну и ту же ячейку.

Первая версия — `HashTableChaining`. Она хранит в каждой ячейке список элементов, то есть если несколько ключей дают одинаковый индекс, они размещаются в одном «корзинном» списке. При вставке таблица проверяет, существует ли уже такой ключ, и либо обновляет его, либо добавляет новую пару. Когда таблица заполняется более чем на 70 %, выполняется расширение: размер удваивается, и все элементы перераспределяются согласно новым индексам. Такой подход сохраняет производительность и позволяет гибко обрабатывать коллизии.

Вторая версия — `HashTableLinear`. Здесь используется линейное пробирование: если позиция занята, алгоритм просто идёт вперёд по массиву, пока не найдёт свободную ячейку. Поиск работает по тому же принципу — проверяются последовательные индексы, пока не встретится либо нужный ключ, либо пустая ячейка. Этот способ прост, но при большом количестве коллизий приводит к образованию длинных последовательных цепочек.

Третья версия — `HashTableDouble`. Она опирается на двойное хеширование: для каждого ключа вычисляются два независимых хеша. Первый определяет начальную позицию, второй — шаг, на который таблица смещается при коллизии. Благодаря этому последовательность проверяемых индексов зависит от ключа и гораздо лучше распределяется по таблице. Это уменьшает вероятность «скучивания» значений и делает поиск эффективнее по сравнению с обычным линейным пробированием.

### test.py
```python
import unittest

from hash_table_chaining import HashTableChaining, HashTableDouble, HashTableLinear

class TestHashTables(unittest.TestCase):

    # Тесты для метода цепочек
    def test_chaining_insert_and_find(self):
        """Проверка добавления и поиска в HashTableChaining"""
        ht = HashTableChaining()
        ht.insert("apple", 10)
        ht.insert("banana", 20)
        self.assertEqual(ht.find("apple"), 10)
        self.assertEqual(ht.find("banana"), 20)
        self.assertIsNone(ht.find("cherry"))  # нет такого ключа

    def test_chaining_collision(self):
        """Проверка обработки коллизий в HashTableChaining"""
        ht = HashTableChaining(size=2)  # малый размер повышает шанс коллизий
        ht.insert("a", 1)
        ht.insert("b", 2)
        # Оба ключа должны быть доступны
        self.assertEqual(ht.find("a"), 1)
        self.assertEqual(ht.find("b"), 2)


    def test_chaining_resize(self):
        """Проверка увеличения размера таблицы при переполнении"""
        ht = HashTableChaining(size=2)
        for i in range(5):  # вызовет увеличение размера
            ht.insert(f"k{i}", i)
        self.assertGreaterEqual(ht.size, 4)  # таблица увеличилась
        self.assertEqual(ht.find("k0"), 0)


    # Тесты для линейного пробирования
    def test_linear_insert_and_find(self):
        """Проверка добавления и поиска в HashTableLinear"""
        ht = HashTableLinear()
        ht.insert("apple", 10)
        ht.insert("banana", 20)
        self.assertEqual(ht.find("apple"), 10)
        self.assertEqual(ht.find("banana"), 20)
        self.assertIsNone(ht.find("cherry"))

    def test_linear_collision(self):
        """Проверка обработки коллизий в HashTableLinear"""
        ht = HashTableLinear(size=3)
        # Подбираем слова с одинаковым хешом вручную
        keys = ["a", "b", "c"]
        for i, k in enumerate(keys):
            ht.insert(k, i)
        # Проверим, что все вставились и доступны
        for i, k in enumerate(keys):
            self.assertEqual(ht.find(k), i)

    def test_linear_overflow(self):
        """Проверка переполнения таблицы при линейном пробировании"""
        ht = HashTableLinear(size=2)
        ht.insert("a", 1)
        ht.insert("b", 2)
        with self.assertRaises(Exception):  # таблица переполнена
            ht.insert("c", 3)


    # Тесты для двойного хеширования
    def test_double_insert_and_find(self):
        """Проверка добавления и поиска в HashTableDouble"""
        ht = HashTableDouble()
        ht.insert("apple", 10)
        ht.insert("banana", 20)
        self.assertEqual(ht.find("apple"), 10)
        self.assertEqual(ht.find("banana"), 20)

    def test_double_collision(self):
        """Проверка коллизий в HashTableDouble"""
        ht = HashTableDouble(size=3)
        keys = ["a", "b", "c"]
        for i, k in enumerate(keys):
            ht.insert(k, i)
        for i, k in enumerate(keys):
            self.assertEqual(ht.find(k), i)

    def test_double_overflow(self):
        """Проверка переполнения таблицы при двойном хешировании"""
        ht = HashTableDouble(size=2)
        ht.insert("a", 1)
        ht.insert("b", 2)
        with self.assertRaises(Exception):  # таблица переполнена
            ht.insert("c", 3)


if __name__ == "__main__":
    unittest.main()
```
Этот файл содержит набор тестов, которые проверяют корректность работы трёх различных реализаций хеш-таблиц. Каждый тест запускает определённые операции и сравнивает полученный результат с ожидаемым, чтобы убедиться, что структура данных ведёт себя правильно.

Для таблицы с цепочками сначала проверяется базовое поведение вставки и поиска: после добавления пары ключ-значение метод `find` должен возвращать именно то, что было сохранено. Затем тестируется ситуация с коллизиями: при маленьком размере таблицы несколько ключей намеренно приводятся к одному индексу, и важно, чтобы все они сохранялись и оставались доступными. Отдельно проверяется автоматическое увеличение размера: когда количество элементов превышает порог, таблица расширяется, и тест убеждается, что данные не потерялись.

Для таблицы с линейным пробированием тесты аналогичны: сначала проверяется правильность работы при обычных условиях, затем — обработка коллизий, когда несколько ключей попадают в одну область и должны размещаться путём последовательного поиска свободного места. Кроме того, предусмотрен тест на переполнение: если таблица полностью занята, попытка вставки должна вызвать исключение, что подтверждает корректную защиту от выхода за пределы.

Для таблицы с двойным хешированием повторяются те же типы проверок, но здесь важна логика вычисления двух разных хешей. Тесты убеждаются, что элементы корректно вставляются и находятся, даже если возникает коллизия на первом хеше. При попытке вставить больше элементов, чем позволяет размер, также должно возникнуть исключение, что подтверждает корректную реализацию алгоритма.

Таким образом, весь набор тестов проверяет основные механизмы работы трёх видов хеш-таблиц: добавление, поиск, реакцию на коллизии и поведение при заполнении структуры.







## Результаты выполнения

### Пример работы программы
```bash
[Вывод программы]
```markdown

### Тестирование
- [ ] Модульные тесты пройдены
- [ ] Интеграционные тесты пройдены
- [ ] Производительность соответствует требованиям

## Выводы
1. [Основной вывод 1]
2. [Основной вывод 2]
3. [Основной вывод 3]

## Ответы на контрольные вопросы
1. [Вопрос] - [Ответ]
2. [Вопрос] - [Ответ]

## Приложения
- [Ссылки на исходный код]
- [Диаграммы и графики]
- [Дополнительные материалы]
```