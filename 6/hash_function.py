def simple_hash(s):
    h = 0
    for ch in s:
        h += ord(ch)  # ord() возвращает числовой код символа
    return h


# Особенности:
# • Очень простая реализация.
# • Не учитывает порядок символов (abc == cab).
# • Работает быстро, но даёт много коллизий.
# Качество распределения:
# • Плохое — значения сильно сгруппированы.
# • Разные строки часто имеют одинаковый хеш.
# • Подходит только для учебных примеров.


def poly_hash(s, p=31, m=10**9+9):
    h = 0
    p_pow = 1
    for ch in s:
        # Умножаем код символа на степень основания p и берём по модулю m
        h = (h + (ord(ch) - ord('a') + 1) * p_pow) % m
        p_pow = (p_pow * p) % m
    return h


# Особенности:
# • Учитывает порядок символов.
# • Использует параметр p (обычно простое число) и модуль m для равномерного распределения.
# • Часто применяется в алгоритмах поиска подстрок (например, Робин-Карп).
# Качество распределения:
# • Хорошее — хеши распределяются равномерно при правильном выборе p и m.
# • Малое количество коллизий.
# • Подходит для сравнения строк и работы с текстами.


def djb2(s):
    h = 5381  # стартовое "магическое" число
    for ch in s:
        h = ((h << 5) + h) + ord(ch)  # то же самое, что h * 33 + ord(ch)
    return h & 0xFFFFFFFF  # ограничиваем 32 битами (типично для DJB2)


# Особенности:
# • Придумана Дэном Бернстайном (Dan Bernstein).
# • Использует множитель 33 — даёт хорошее распределение при низкой стоимости вычислений.
# • Очень популярна в хеш-таблицах (C, PHP и др.).
# Качество распределения:
# • Отличное — хеши распределяются равномерно даже для похожих строк.
# • Коллизии редки.
# • Хороший баланс между скоростью и качеством.
